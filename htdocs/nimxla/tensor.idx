XLAError	nimxla/tensor.html#XLAError	tensor: XLAError	
ElemType	nimxla/tensor.html#ElemType	tensor: ElemType	
InvalidType	nimxla/tensor.html#InvalidType	DataType.InvalidType	
Bool	nimxla/tensor.html#Bool	DataType.Bool	
I8	nimxla/tensor.html#I8	DataType.I8	
I16	nimxla/tensor.html#I16	DataType.I16	
I32	nimxla/tensor.html#I32	DataType.I32	
I64	nimxla/tensor.html#I64	DataType.I64	
U8	nimxla/tensor.html#U8	DataType.U8	
U16	nimxla/tensor.html#U16	DataType.U16	
U32	nimxla/tensor.html#U32	DataType.U32	
U64	nimxla/tensor.html#U64	DataType.U64	
F16	nimxla/tensor.html#F16	DataType.F16	
F32	nimxla/tensor.html#F32	DataType.F32	
F64	nimxla/tensor.html#F64	DataType.F64	
Tuple	nimxla/tensor.html#Tuple	DataType.Tuple	
OpaqueType	nimxla/tensor.html#OpaqueType	DataType.OpaqueType	
C64	nimxla/tensor.html#C64	DataType.C64	
BF16	nimxla/tensor.html#BF16	DataType.BF16	
Token	nimxla/tensor.html#Token	DataType.Token	
C128	nimxla/tensor.html#C128	DataType.C128	
DataType	nimxla/tensor.html#DataType	tensor: DataType	
ArrayKind	nimxla/tensor.html#ArrayKind	ShapeKind.ArrayKind	
TupleKind	nimxla/tensor.html#TupleKind	ShapeKind.TupleKind	
ShapeKind	nimxla/tensor.html#ShapeKind	tensor: ShapeKind	
Shape	nimxla/tensor.html#Shape	tensor: Shape	
Literal	nimxla/tensor.html#Literal	tensor: Literal	
Tensor	nimxla/tensor.html#Tensor	tensor: Tensor	
checkError	nimxla/tensor.html#checkError,status_t	tensor: checkError(status: status_t)	
len	nimxla/tensor.html#len,Tensor	tensor: len(t: Tensor): int	
rawPtr	nimxla/tensor.html#rawPtr,Tensor	tensor: rawPtr(t: Tensor): pointer	
dtypeOf	nimxla/tensor.html#dtypeOf,typedesc[ElemType]	tensor: dtypeOf(T: typedesc[ElemType]): DataType	
arrayShape	nimxla/tensor.html#arrayShape,DataType,varargs[int]	tensor: arrayShape(dtype: DataType; dims: varargs[int]): Shape	
`==`	nimxla/tensor.html#==,Shape,Shape	tensor: `==`(s1, s2: Shape): bool	
`$`	nimxla/tensor.html#$,Shape	tensor: `$`(s: Shape): string	
shape	nimxla/tensor.html#shape,Tensor[T: ElemType]	tensor: shape[T: ElemType](t: Tensor[T]): Shape	
newTensor	nimxla/tensor.html#newTensor,varargs[int]	tensor: newTensor[T: ElemType](dims: varargs[int]): Tensor[T]	
zeros	nimxla/tensor.html#zeros,varargs[int]	tensor: zeros[T: ElemType](dims: varargs[int]): Tensor[T]	
fill	nimxla/tensor.html#fill,openArray[int],T	tensor: fill[T: ElemType](dims: openArray[int]; value: T): Tensor[T]	
toTensor	nimxla/tensor.html#toTensor,T	tensor: toTensor[T: ElemType](value: T): Tensor[T]	
toTensor	nimxla/tensor.html#toTensor,openArray[T]	tensor: toTensor[T: ElemType](values: openArray[T]): Tensor[T]	
toTensor	nimxla/tensor.html#toTensor,HSlice[int,int]	tensor: toTensor[T: ElemType](slice: HSlice[int, int]): Tensor[T]	
`[]`	nimxla/tensor.html#[],Tensor[T: ElemType],varargs[int]	tensor: `[]`[T: ElemType](t: Tensor[T]; ix: varargs[int]): T	
`[]=`	nimxla/tensor.html#[]=,Tensor,varargs[int],T	tensor: `[]=`[T: ElemType](t: var Tensor; ix: varargs[int]; value: T)	
`==`	nimxla/tensor.html#==,Tensor[T: ElemType],Tensor[T: ElemType]	tensor: `==`[T: ElemType](t1, t2: Tensor[T]): bool	
toSeq	nimxla/tensor.html#toSeq,Tensor[T: ElemType]	tensor: toSeq[T: ElemType](t: Tensor[T]): seq[T]	
clone	nimxla/tensor.html#clone,Tensor[T: ElemType]	tensor: clone[T: ElemType](t: Tensor[T]): Tensor[T]	
reshape	nimxla/tensor.html#reshape,Tensor[T: ElemType],varargs[int]	tensor: reshape[T: ElemType](t: Tensor[T]; dims: varargs[int]): Tensor[T]	
setPrintOpts	nimxla/tensor.html#setPrintOpts,int,int,int,int	tensor: setPrintOpts(minWidth = 8; precision = 6; floatMode = ffDefault;\n             threshold = 1000; edgeitems = 4)	
format	nimxla/tensor.html#format,Tensor[T: ElemType]	tensor: format[T: ElemType](t: Tensor[T]): string	
`$`	nimxla/tensor.html#$,Tensor[T: ElemType]	tensor: `$`[T: ElemType](t: Tensor[T]): string	
toShape	nimxla/tensor.html#toShape,shape_t	tensor: toShape(s: shape_t; topLevel = true): Shape	
newLiteral	nimxla/tensor.html#newLiteral,DataType,openArray[int]	tensor: newLiteral(dtype: DataType; dims: openArray[int]): Literal	
rawPtr	nimxla/tensor.html#rawPtr,Literal	tensor: rawPtr(lit: Literal): literal_t	
addrOf	nimxla/tensor.html#addrOf,Literal	tensor: addrOf(lit: Literal): ptr literal_t	
shape	nimxla/tensor.html#shape,Literal	tensor: shape(lit: Literal): Shape	
len	nimxla/tensor.html#len,Literal	tensor: len(lit: Literal): int	
dtype	nimxla/tensor.html#dtype,Literal	tensor: dtype(lit: Literal): DataType	
clone	nimxla/tensor.html#clone,Literal	tensor: clone(lit: Literal): Literal	
reshape	nimxla/tensor.html#reshape,Literal,varargs[int]	tensor: reshape(lit: Literal; dims: varargs[int]): Literal	
convert	nimxla/tensor.html#convert,Literal,DataType	tensor: convert(lit: Literal; dtype: DataType): Literal	
toLiteral	nimxla/tensor.html#toLiteral,Tensor[T: ElemType]	tensor: toLiteral[T: ElemType](t: Tensor[T]): Literal	
toTensor	nimxla/tensor.html#toTensor,Literal	tensor: toTensor[T: ElemType](lit: Literal): Tensor[T]	
i32	nimxla/tensor.html#i32,Literal	tensor: i32(lit: Literal): Tensor[int32]	
i64	nimxla/tensor.html#i64,Literal	tensor: i64(lit: Literal): Tensor[int64]	
f32	nimxla/tensor.html#f32,Literal	tensor: f32(lit: Literal): Tensor[float32]	
f64	nimxla/tensor.html#f64,Literal	tensor: f64(lit: Literal): Tensor[float64]	
decomposeTuple	nimxla/tensor.html#decomposeTuple,Literal	tensor: decomposeTuple(lit: Literal): seq[Literal]	
`$`	nimxla/tensor.html#$,Literal	tensor: `$`(lit: Literal): string	
lit	nimxla/tensor.html#lit,int32	tensor: lit(value`gensym90: int32): Literal	
lit	nimxla/tensor.html#lit,int64	tensor: lit(value`gensym92: int64): Literal	
lit	nimxla/tensor.html#lit,float32	tensor: lit(value`gensym94: float32): Literal	
lit	nimxla/tensor.html#lit,float64	tensor: lit(value`gensym96: float64): Literal	
